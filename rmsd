#!/usr/bin/env -S uv run --script

# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "rich",
#     "InquirerPy",
#     "numpy",
#     "scipy",
# ]
# ///

from rich.progress import Progress
from rich.console import Console
from rich.table import Table
from rich import box

from pathlib import Path
from InquirerPy import inquirer

import os
import glob
import argparse
import json
import operator
import sys
from concurrent.futures import ThreadPoolExecutor, as_completed

# Add the script's directory to the Python path to allow importing local scripts
sys.path.append(os.path.dirname(os.path.realpath(__file__)))

from calculate_rmsd import get_rmsd_from_files


CHEMCRAFT_PATH = "/home/vport/.wine/drive_c/chemcraft/Chemcraft.exe"

CACHE_FILE = ".rmsd"

class InvalidXYZfile(Exception):
    pass


class AtomNrMismatch(Exception):
    pass


class Rmsd:
    def __init__(self, file1, file2, rmsd, weighted):
        self.file1 = file1
        self.file2 = file2
        self.rmsd = rmsd
        self.weighted = weighted

    def toJSON(self):
        return json.dumps(self.__dict__)

    def __eq__(self, other):
        return self.file1 == other.file1 and self.file2 == other.file2

    def __len__(self):
        with open(self.file1) as f:
            try:
                len1=int(f.readlines()[0])
            except:
                raise InvalidXYZfile("{} is an invalid xyz file".format(self.file1))

        with open(self.file2) as f:
            try:
                len2=int(f.readlines()[0])
            except:
                raise InvalidXYZfile("{} is an invalid xyz file".format(self.file2))

        if len1 != len2:
            raise AtomNrMismatch("{} and {} do not have a compatible number of atoms".format(self.file1, self.file2))

        return len1

    def weighted_rmsd(self):
        if self.rmsd is None:
            return 0
        else:
            return (self.rmsd/len(self)) 

    def calculate_rmsd(self):
        if self.rmsd is None:
            try:
                rmsd_val, num_atoms = get_rmsd_from_files(self.file1, self.file2)
                self.rmsd = rmsd_val
                self.weighted = self.rmsd / num_atoms if num_atoms > 0 else 0
            except (ValueError, FileNotFoundError) as e:
                print(f"Error calculating RMSD for {self.file1} and {self.file2}: {e}", file=sys.stderr)
                self.rmsd = None
                self.weighted = None
        return self


    def view(self):
        file1 = ["wine", CHEMCRAFT_PATH, self.file1]
        file2 = ["wine", CHEMCRAFT_PATH, self.file2]
        subprocess.Popen(file1, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        subprocess.Popen(file2, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)


def handle_args():
    parser = argparse.ArgumentParser(
        description="Calculate RMSD between files matching a pattern."
    )

    parser.add_argument(
        "-r",
        "--remove",
        action="store_true",
        help="Remove every file that has the root of the same xyz file that was filtered.",
    )

    parser.add_argument(
        "-t",
        "--tolerance",
        type=float,
        help="Tolerance for RMSD comparison.",
    )

    parser.add_argument(
        "-v",
        "--view",
        action="store_true",
        help="Open files in chemcraft for inspection.",
    )

    parser.add_argument(
        "-w",
        "--workers",
        type=int,
        default=os.cpu_count(),
        help="Number of parallel workers to use for calculation.",
    )

    parser.add_argument(
        "files",
        nargs="+",
        help="List of xyz files (at least two are required), format is mandatory to be .xyz",
    )

    return parser.parse_args()


def load_cache():
    rmsds = []
    try:
        with open(CACHE_FILE) as cache_data:
            for blob in json.load(cache_data):
                rmsds.append(Rmsd(**blob))
    except FileNotFoundError:
        print("No cache file found.")
    return rmsds


def clean_file(file, rmsds):
    for blob in rmsds:
        if blob.file1 == file or blob.file2 == file:
            rmsds.remove(blob)

    # clean all files that contain the rootname of the xyz file
    rootname = Path(file).stem

    for filename in glob.glob(f"./{rootname}*"):
        os.remove(filename)


def generate_rmsd_list(cache: list[Rmsd], files):

    rmsds = []

    for idx1 in range(0, len(files)):
        file_1 = files[idx1]
        for idx2 in range(idx1 + 1, len(files)):
            file_2 = files[idx2]

            obj = Rmsd(file_1, file_2, None, None)

            if obj in cache:
                cached_obj = cache[cache.index(obj)]
                # Ensure cached objects have values if they are meant to be calculated
                if cached_obj.rmsd is None:
                    rmsds.append(obj) # Add the new object to be calculated
                else:
                    rmsds.append(cached_obj)
            else:
                rmsds.append(obj)

    return rmsds


def gen_rich_table(rmsds, tolerance):
    table = Table(box=box.MINIMAL)
    table.add_column("File 1", justify="center")
    table.add_column("File 2", justify="center")
    table.add_column("RMSD", justify="center")
    table.add_column("Weighted RMSD", justify="center")

    for obj in rmsds:
        if obj.rmsd is None: continue
        if tolerance is not None:
            if obj.rmsd < tolerance:
                table.add_row(obj.file1, obj.file2, "{:.3f}".format(obj.rmsd), "{:.2f}%".format(obj.weighted * 100))
        else:
            table.add_row(obj.file1, obj.file2, "{:.3f}".format(obj.rmsd), "{:.2f}%".format(obj.weighted * 100))

    return table


def ask_view_pair(rmsds, tolerance):
    rmsd_choices = []
    for obj in rmsds:
        if obj.rmsd is None: continue
        if tolerance is not None:
            if obj.rmsd < tolerance:
                rmsd_choices.append(obj)
        else:
            rmsd_choices.append(obj)

    string_choices = [
        f"file1: {i.file1}, file2: {i.file2}, rmsd: {i.rmsd:.3f}"
        for i in rmsd_choices
    ]

    choice = inquirer.fuzzy(
        message="Select a file pair",
        choices=string_choices,
        default=None,
    ).execute()

    return rmsd_choices[string_choices.index(choice)]


if __name__ == "__main__":
    args = handle_args()
    cache = load_cache()

    all_rmsds = generate_rmsd_list(cache, args.files)
    to_calculate = [r for r in all_rmsds if r.rmsd is None]
    total_tasks = len(to_calculate)

    filtered = []

    try:
        with Progress() as progress:
            task = progress.add_task("[cyan]Calculating RMSD...", total=total_tasks)
            with ThreadPoolExecutor(max_workers=args.workers) as executor:
                futures = {executor.submit(obj.calculate_rmsd): obj for obj in to_calculate}

                for future in as_completed(futures):
                    result = future.result()
                    progress.update(task, advance=1)
                    if args.tolerance is not None and result.rmsd is not None:
                        if result.rmsd < args.tolerance:
                            filtered.append(result.file2)

        if args.remove:
            print(f"Removing {len(filtered)} files with RMSD < {args.tolerance}...")
            for file in set(filtered): # Use set to remove duplicates
                clean_file(file, all_rmsds)

        with open(CACHE_FILE, "w") as c:
            json.dump(all_rmsds, c, default=lambda o: o.__dict__, indent=4)

    except KeyboardInterrupt:
        print("\nCalculation interrupted. Saving cache...")
        with open(CACHE_FILE, "w") as c:
            json.dump(all_rmsds, c, default=lambda o: o.__dict__, indent=4)
        sys.exit(1)

    all_rmsds.sort(key=lambda x: x.rmsd if x.rmsd is not None else float('inf'), reverse=True)
    table = gen_rich_table(all_rmsds, args.tolerance)
    console = Console()
    console.print(table)

    if args.view:
        another = True
        while another:
            pair = ask_view_pair(all_rmsds, args.tolerance)
            pair.view()

            another = inquirer.confirm(
                message="Open another pair?", default=False
            ).execute()
